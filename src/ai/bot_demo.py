import tensorflow as tf
import json
import numpy as np
from example_game import sample_game_json
from collections import defaultdict
import urllib
from random import randint
import h5py
import time
from tempfile import TemporaryFile

save_path = './model/dnn/weights_d3.h5'

training_path = './train/'

def main():
	# trainModel()
	print(predictMove(json.loads(sample_game_json)))

# trainModel trains a model loaded from loadModel,
# and saves the weights to save_path.
def trainModel():
	model = loadModel()
	traindata = np.load("%s%sdata2.npz" % (training_path, "mick"))["arr_0"]
	targedata = np.load("%s%sdata2.npz" % (training_path, "rock"))["arr_0"]
	traindata = np.reshape(traindata, (10010, 53, 3))
	targedata = np.reshape(targedata, (10010, 52))
	model.fit(traindata, targedata, batch_size=10, epochs=1)
	model.save_weights(save_path)

# loadModel returns a new Keras neural network, 
# which loads weights from save_path.
def loadModel():
	model = tf.keras.Sequential()
	model.add(tf.keras.layers.InputLayer(batch_input_shape=(10,53,3)))
	model.add(tf.keras.layers.Flatten())
	model.add(tf.keras.layers.Dense(2756,
		activation='softmax'))
	model.add(tf.keras.layers.Dense(2756))
	model.add(tf.keras.layers.Dense(2756))
	model.add(tf.keras.layers.Dense(689))
	model.add(tf.keras.layers.Dense(52))
	model.add(tf.keras.layers.Dropout(0.5))
	model.compile(
		optimizer='rmsprop',
		loss='binary_crossentropy',
		metrics=['accuracy'])
	model.load_weights(save_path)
	return model

def signb(b):
	return 1 if b else -1

# batchConvertTrainingJson is used to turn the files generated by Trainer.go
# into two NumPy archives, for efficiency.
def batchConvertTrainingJson(traindir, num=1001):
	mick = np.empty((num, 10, 53, 3), np.int8)
	rock = np.empty((num, 10, 52), np.int8)
	for i in range(1, num):
		trstr = "%s%s%d" % (traindir, "/mick", i)
		tastr = "%s%s%d" % (traindir, "/rock", i)
		try:
			valids = np.empty((10, 52), type(True))
			vs = np.vectorize(signb)
			traindata = open(trstr, 'r')
			targedata = open(tastr, 'r')
			trdata = json.load(traindata)[10:]
			tr = np.array(trdata)
			for i in range(len(trdata)):
				for j in range(len(trdata[i])):
					if tr[i][j][0]:
						valids[i][j] = True
			tr = vs(tr)
			mick[i-1] = tr
			tadata = json.load(targedata)[10:]
			ta = vs(np.array(tadata))
			for i in range(len(ta)):
				for j in range(len(ta[i])):
					if ta[i][j] == -1 and valids[i][j]:
						ta[i][j] = 0
			rock[i-1] = ta
		except Exception as e:
			print(e)
			continue
		finally:
			traindata.close()
			targedata.close()
	np.savez("%s%s" % (training_path, "mickdata2"), mick)
	np.savez("%s%s" % (training_path, "rockdata2"), rock)

# flattenGame turns a Game state object
# into a flat 2d list with the following shape:
# [Card] (sorted by Suit/Value)
# 	[canMove,
# 	inTrick,
# 	inPlay]
# ,
# [OpponentHasAllPoints, SelfHasAllPoints, HeartsBroken]
def flattenGame(obj):
	out = []

	for card in obj["Trick"]:
		card["inTrick"] = True
		out.append(card)

	valid = validMoves(obj)

	for card in valid:
		out.append(card)
	for i in range(4):
		if i == obj["ToPlay"]: continue
		for card in obj["Players"][i]["Hand"]:
			out.append(card)

	for card in out:
		card["inPlay"] = True

	m = 0
	allPoints = -1
	for i in range(4):
		k = 0
		for card in obj["Players"][i]["Points"]:
			allPoints = -1
			k += 1
			m += 1
			out.append(card)
		if m > 0 and k == m:
			allPoints = i
			
	out = sorted(out, key=lambda v: (v["Suit"], v["Value"]))
	
	xtr = []
	if allPoints > -1:
		if obj["ToPlay"] == allPoints:
			xtr = (0,1,obj["HeartsBroken"])
		else:
			xtr = (1,0,obj["HeartsBroken"])
	out.append(xtr)
	return np.array(list(map(flattenCard, out)))

# unflattenMove returns a Move from a given neural network output,
# where the Card chosen is the network's best guess.
def unflattenMove(obj, side):
	card = { }
	top = np.sort(np.copy(obj))[len(obj) - 1]
	for i in range(len(obj)):
		if obj[i] == top:
			card["Suit"] = i / 13
			card["Value"] = i % 13
	return {
		"Side":side,
		"Card":card
	}

# flattenMove turns a Move into a FlatMove.
def flattenMove(card):
	res = np.zeroes(52,3)
	res[card["Suit"] * 13 + card["Value"]] = 1
	return res

# flattenCard is used by flattenGame to convert card objects into bool[3]'s.
def flattenCard(c):
	c = defaultdict(lambda:False, c)
	return (
		c["canMove"],
		c["inTrick"],
		c["inPlay"]
		)

# validMoves takes a game object, and returns the hand of the current player
# with extra data on the cards indicating whether the card is a valid move.
def validMoves(game, exclude=False):
	hand = game["Players"][game["ToPlay"]]["Hand"]
	trick = game["Trick"]
	heartsbroken = game["HeartsBroken"]
	allClear = False
	if len(trick) == 0:
		if heartsbroken:
			allClear = True
		else:
			for card in hand:
			 if (card["Suit"] != 2 and not
			  	(card["Suit"] == 3 and
			     card["Value"] == 10)):
			 	card["canMove"] = True
	else:
		allClear = True
		for card in hand:
			if card["Suit"] == trick[0]["Suit"]:
				card["canMove"] = True
				allClear = False
	if allClear:
		for card in hand:
			card["canMove"] = True
	if exclude:
		return [x for x in hand if x["canMove"]]
	return hand

# predictMove takes a Game and a neural network model,
# and returns the network's best predicted move.
def predictMove(game, model=loadModel()):
	s = game["ToPlay"]
	ia = np.empty((10,53,3))
	ia[0] = flattenGame(game)
	fm = model.predict(ia, batch_size=10)
	# return fm[0]
	return unflattenMove(fm[0], s)

if __name__ == "__main__":
	main()
